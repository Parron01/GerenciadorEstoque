import type { Product } from "@/models/product";
import type { Lote, LotePayload } from "@/models/lote";
import type {
  BackendHistoryRecord,
  ParsedHistoryRecord,
  HistoryBatchInput,
  PaginatedHistoryBatchGroups, // Added
  HistoryBatchGroup, // Added
} from "@/models/history";
import { useAuthStore } from "@/stores/authStore";

const getApiBaseUrl = () => {
  const authStore = useAuthStore(); // Access store instance here or pass as arg if preferred
  return authStore.API_BASE_URL;
};

const getAuthHeaders = (operationBatchId?: string) => {
  const authStore = useAuthStore();
  const headers: HeadersInit = {
    "Content-Type": "application/json",
  };
  if (authStore.token) {
    headers["Authorization"] = `Bearer ${authStore.token}`;
  }
  // If an operationBatchId is provided (e.g., from ProductTable's confirmUpdates),
  // it's sent as a custom header. The backend uses this to group all history
  // records generated by the subsequent API calls under a single BatchID.
  if (operationBatchId) {
    headers["X-Operation-Batch-ID"] = operationBatchId;
  }
  return headers;
};

// Helper to handle API responses
async function handleResponse<T>(response: Response): Promise<T> {
  if (!response.ok) {
    let errorData;
    try {
      errorData = await response.json();
      console.error("API Error Response Body:", errorData); // Log the full error response
    } catch (e) {
      errorData = {
        message: response.statusText,
        detail: "Failed to parse error JSON.",
      };
      console.error(
        "API Error: Could not parse error JSON. Status:",
        response.status,
        "StatusText:",
        response.statusText
      );
    }
    throw new Error(
      errorData.message || errorData.error || `API error: ${response.status}`
    ); // Use errorData.error if message is not present
  }
  return response.json() as Promise<T>;
}

// Product Services
export async function fetchProducts(): Promise<Product[]> {
  const response = await fetch(`${getApiBaseUrl()}/api/products`, {
    headers: getAuthHeaders(), // No batch ID for fetching all
  });
  const products = await handleResponse<Product[]>(response);
  // Backend sends product_id and data_validade for lotes, map to frontend model
  return products.map((p) => ({
    ...p,
    lotes: p.lotes?.map((l: any) => ({
      ...l,
      productId: l.productId || l.product_id,
      dataValidade: l.dataValidade || l.data_validade, // Map data_validade to dataValidade
    })),
  }));
}

export async function fetchProductById(productId: string): Promise<Product> {
  const response = await fetch(`${getApiBaseUrl()}/api/products/${productId}`, {
    headers: getAuthHeaders(), // No batch ID for fetching one
  });
  const product = await handleResponse<Product>(response);
  // Backend sends product_id and data_validade for lotes, map to frontend model
  return {
    ...product,
    lotes: product.lotes?.map((l: any) => ({
      ...l,
      productId: l.productId || l.product_id,
      dataValidade: l.dataValidade || l.data_validade, // Map data_validade to dataValidade
    })),
  };
}

export async function createProductApi(
  productData: Omit<Product, "id" | "lotes" | "quantity"> & {
    quantity?: number;
  }
  // No operationBatchId here, it's a standalone operation
): Promise<Product> {
  const response = await fetch(`${getApiBaseUrl()}/api/products`, {
    method: "POST",
    headers: getAuthHeaders(), // No batch ID for direct creation
    body: JSON.stringify(productData),
  });
  return handleResponse<Product>(response);
}

export async function updateProductApi(
  productId: string,
  productData: Partial<Pick<Product, "name" | "unit" | "quantity">>, // Allow quantity update
  operationBatchId?: string
): Promise<Product> {
  const response = await fetch(`${getApiBaseUrl()}/api/products/${productId}`, {
    method: "PUT",
    headers: getAuthHeaders(operationBatchId),
    body: JSON.stringify(productData),
  });
  return handleResponse<Product>(response);
}

export async function deleteProductApi(
  productId: string
  // No operationBatchId here, it's a standalone operation
): Promise<void> {
  const response = await fetch(`${getApiBaseUrl()}/api/products/${productId}`, {
    method: "DELETE",
    headers: getAuthHeaders(), // No batch ID for direct deletion
  });
  if (!response.ok) {
    const errorData = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(errorData.message || `API error: ${response.status}`);
  }
}

// Lote Services
export async function createLoteApi(
  productId: string,
  loteData: LotePayload,
  operationBatchId?: string
): Promise<Lote> {
  // Prepare payload for backend, mapping frontend field names to backend field names if necessary
  const backendPayload: any = {
    quantity: loteData.quantity,
  };

  if (loteData.dataValidade) {
    // Backend expects "YYYY-MM-DD"
    backendPayload.data_validade = loteData.dataValidade.split("T")[0];
  }
  // The backend error "failed on the 'required' tag" implies it IS required.
  // If loteData.dataValidade can be undefined/empty, and the backend allows it,
  // then this conditional assignment is fine. If it's always required by backend,
  // ensure loteData.dataValidade always has a value before this point.

  console.log(
    `Creating lote for product ${productId} with operationBatchId: ${operationBatchId}. Backend Payload:`,
    JSON.stringify(backendPayload, null, 2)
  );

  const response = await fetch(
    `${getApiBaseUrl()}/api/products/${productId}/lotes`,
    {
      method: "POST",
      headers: getAuthHeaders(operationBatchId),
      body: JSON.stringify(backendPayload), // Send the transformed payload
    }
  );
  const lote = await handleResponse<Lote>(response);
  // Map response back if necessary (e.g., if backend returns data_validade)
  // Backend will likely return data_validade in "YYYY-MM-DDTHH:mm:ssZ" format from the DB.
  // Frontend model expects a string, so this is fine.
  return {
    ...lote,
    productId: lote.productId || (lote as any).product_id,
    dataValidade: (lote as any).data_validade || lote.dataValidade, // Ensure frontend model gets dataValidade
  };
}

export async function updateLoteApi(
  loteId: string,
  loteData: LotePayload,
  operationBatchId?: string
): Promise<Lote> {
  const backendPayload: any = {
    quantity: loteData.quantity,
  };

  if (loteData.dataValidade) {
    // Backend expects "YYYY-MM-DD"
    backendPayload.data_validade = loteData.dataValidade.split("T")[0];
  }

  console.log(
    `Updating lote ${loteId} with operationBatchId: ${operationBatchId}. Backend Payload:`,
    JSON.stringify(backendPayload, null, 2)
  );

  const response = await fetch(`${getApiBaseUrl()}/api/lotes/${loteId}`, {
    method: "PUT",
    headers: getAuthHeaders(operationBatchId),
    body: JSON.stringify(backendPayload), // Send the transformed payload
  });
  const lote = await handleResponse<Lote>(response);
  // Map response back
  return {
    ...lote,
    productId: lote.productId || (lote as any).product_id,
    dataValidade: (lote as any).data_validade || lote.dataValidade,
  };
}

export async function deleteLoteApi(
  loteId: string,
  operationBatchId?: string
): Promise<void> {
  const response = await fetch(`${getApiBaseUrl()}/api/lotes/${loteId}`, {
    method: "DELETE",
    headers: getAuthHeaders(operationBatchId),
  });
  if (!response.ok) {
    const errorData = await response
      .json()
      .catch(() => ({ message: response.statusText }));
    throw new Error(errorData.message || `API error: ${response.status}`);
  }
}

// History Service

// Fetches ungrouped history - less used now for main history view
export async function fetchHistoryApi(
  limit: number = 20,
  offset: number = 0
): Promise<ParsedHistoryRecord[]> {
  const response = await fetch(
    `${getApiBaseUrl()}/api/history?limit=${limit}&offset=${offset}`,
    {
      headers: getAuthHeaders(),
    }
  );
  const backendRecords = await handleResponse<BackendHistoryRecord[]>(response);

  // Parse ChangeDetails and map to ParsedHistoryRecord
  return backendRecords.map((record) => {
    let parsedDetails;
    try {
      parsedDetails = JSON.parse(record.ChangeDetails);
    } catch (e) {
      console.error(
        "Failed to parse ChangeDetails for history record:",
        record.ID,
        e
      );
      parsedDetails = { error: "Failed to parse details" };
    }
    return {
      id: record.ID,
      entityType: record.EntityType,
      entityId: record.EntityID,
      details: parsedDetails,
      createdAt: record.CreatedAt,
      batchId: record.BatchID || record.ID, // Use BatchID if available, otherwise fallback to record ID
    };
  });
}

// New method for batch history operations (sending a pre-made batch from client)
// This will be less used by ProductTable, but kept for API completeness
export async function createHistoryBatchApi(
  entries: HistoryBatchInput[]
): Promise<{ batchId: string; count: number }> {
  const response = await fetch(`${getApiBaseUrl()}/api/history/batch`, {
    method: "POST",
    headers: getAuthHeaders(),
    body: JSON.stringify(entries),
  });
  return handleResponse<{ batchId: string; count: number }>(response);
}

// Fetches records for a specific batch ID - less used now for main history view
export async function fetchHistoryBatchApi(
  batchId: string
): Promise<ParsedHistoryRecord[]> {
  const response = await fetch(
    `${getApiBaseUrl()}/api/history/batch/${batchId}`,
    {
      headers: getAuthHeaders(),
    }
  );
  const backendRecords = await handleResponse<BackendHistoryRecord[]>(response);

  // Process records similar to fetchHistoryApi
  return backendRecords.map((record) => {
    let parsedDetails;
    try {
      parsedDetails = JSON.parse(record.ChangeDetails);
    } catch (e) {
      console.error(
        "Failed to parse ChangeDetails for history record:",
        record.ID,
        e
      );
      parsedDetails = { error: "Failed to parse details" };
    }
    return {
      id: record.ID,
      entityType: record.EntityType,
      entityId: record.EntityID,
      details: parsedDetails,
      createdAt: record.CreatedAt,
      batchId: record.BatchID || record.ID,
    };
  });
}

// NEW: Fetch history grouped by batch ID
export async function fetchGroupedHistoryApi(
  page: number = 1,
  pageSize: number = 10
): Promise<PaginatedHistoryBatchGroups> {
  const response = await fetch(
    `${getApiBaseUrl()}/api/history/grouped?page=${page}&pageSize=${pageSize}`,
    {
      headers: getAuthHeaders(),
    }
  );
  const paginatedGroups =
    await handleResponse<PaginatedHistoryBatchGroups>(response);

  // Map and Parse ChangeDetails within each record of each group
  paginatedGroups.groups.forEach((group: HistoryBatchGroup) => {
    group.records = group.records.map((record: any) => {
      // Backend record structure (from logs):
      // record.id (history entry ID)
      // record.date (timestamp for createdAt)
      // record.entityType
      // record.entityId
      // record.changes (this is the parsed ChangeDetails object from backend)
      // record.batchId
      // record.productNameContext (optional)

      // Frontend ParsedHistoryRecord structure:
      // id, entityType, entityId, details, createdAt, batchId, productNameContext

      let parsedDetails = record.changes || record.details; // Prioritize 'changes' from backend, fallback to 'details' if already mapped

      // This block might be redundant if backend's /grouped endpoint *always* sends 'changes' as a parsed object.
      // If 'ChangeDetails' (capitalized) is a string field from backend, it needs parsing.
      // However, the current logs suggest 'changes' (lowercase) is already an object.
      if (
        record.ChangeDetails &&
        typeof record.ChangeDetails === "string" &&
        !parsedDetails
      ) {
        try {
          console.warn(
            "Parsing ChangeDetails string in frontend for record:",
            record.id
          );
          parsedDetails = JSON.parse(record.ChangeDetails);
        } catch (e) {
          console.error(
            "Failed to parse ChangeDetails string in grouped history (fallback):",
            record.id,
            e
          );
          parsedDetails = {
            error: "Failed to parse details string from ChangeDetails",
          };
        }
      }

      // Ensure 'details' is an object, even if it's just an error object.
      if (typeof parsedDetails !== "object" || parsedDetails === null) {
        // If parsedDetails is not a valid object (e.g. undefined, string from a bad parse)
        // console.warn(`Details for record ${record.id || record.ID} was not a valid object, received:`, parsedDetails);
        // parsedDetails = { error: "Details were not a valid object or were missing.", original: parsedDetails };
      }

      return {
        id: record.id || record.ID,
        entityType: record.entityType || record.EntityType,
        entityId: record.entityId || record.EntityID,
        details: parsedDetails || { error: "Details not found in record" },
        createdAt: record.date || record.createdAt || record.CreatedAt,
        batchId: record.batchId || record.BatchID,
        productNameContext: record.productNameContext,
      };
    });
  });

  // Consolidated log for all fetched and processed history groups
  console.log(
    "Processed Paginated History Groups:",
    JSON.stringify(paginatedGroups, null, 2)
  );

  return paginatedGroups;
}
